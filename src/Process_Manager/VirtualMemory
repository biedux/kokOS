package VirtualMemory;

import RAM.*;
import Process_Manager.*;
import java.util.*;

public class VirtualMemory {
    static Memory Ram;
    /**
     * Plik wymiany.
     * Integer is processID
     * wektor wektorów z kodem
     */
    static Map<Integer, Vector<Vector<Character>>> PageFile = new HashMap<>(4096);
    // mapa wszystkich użytych tablic stonic
    static Map<Integer, Vector<Page>> PageTables = new HashMap<>();
    /**
     * Kolejka  ofiar
     */
    static Vector<Integer> victimQueue = new Vector<>();


    //metoda która pobiera nowy proces,wczytuje do pliku wymiany program, nadaje tablice stronic i wcztytuje 1 stronice do ramu
    public static void nowyproces(PCB proces) {
        Vector<Vector<Character>> program = new Vector<>(new Vector<>());
        proces.setPageTable(new Vector<Page>());
        Vector<Page> pageTable = proces.getPageTable();
        double maxPageID = Math.ceil(proces.getCode().length() / 16);
        if(maxPageID==0) maxPageID=1;
        for (int currentPageID = 0; currentPageID < maxPageID; currentPageID++) {
            Vector<Character> page = new Vector<>();
            pageTable.add(new Page());
            for (int j = 0; j < 32; j++) {
                try {
                    //jbc zmienic
                    page.add(proces.getCode().charAt(j + currentPageID * 32));

                } catch (Exception e) {
                    //System.out.println(e.getMessage());
                }

            }
            program.add(page);
            putInfoToPageTable(proces.getID(), pageTable);
            putProcessToPageFile(proces.getID(), program);
            putPageInRam(proces, proces.getID(), 0);
        }
    }

    static void putPageInRam(PCB proces, int procID, int pageID) {

        Vector<Page> pageTable = proces.getPageTable();
        Vector<Character> Programwstornie = PageFile.get(procID).get(pageID);
        //System.out.println(pageID + " " + Programwstornie);
        int i = 0;
        //System.out.println(" --------------------------" + victimQueue.size());
        //printPageTable(procID);
        if (victimQueue.size() < 15) {
            for (int fID = 0; fID < 15; fID++) {
                if (putPageIn(fID, Programwstornie)) {
                    updatePageTables(procID, pageID, fID, true);
                    //printPageTable(procID);
                    victimQueue.add(fID);
                    break;
                }
            }
        } else {
            System.out.println(victimQueue.size());
            /**Jeśli nie ma ramki musimy znalezc ofiarę*/
            for (int j=0;j<victimQueue.size();i++)
                if (pageTable.get(i).valid = true) {
                    pageTable.get(i).valid = false;
                    victimQueue.add(pageTable.get(i).nrramki);

                } else {
                    System.out.println("Wyjmujemy stone");
                    takepageout(proces, pageID);
                    if (putPageIn(pageTable.get(i).nrramki, Programwstornie)) {
                        updatePageTables(procID, pageID, pageTable.get(i).nrramki, true);
                        victimQueue.add(pageTable.get(i).nrramki);
                    }
                }
        }

    }



    static boolean putPageIn(int FrameID, Vector<Character> Page) {
        /**Method that puts certain page from pageFile into RAM*/
        return Ram.writeFrame(Page, FrameID);
    }

    static boolean pageExists(int procID, int pageID) {

        try {
            PageTables.get(procID).get(pageID);
            return true;
        } catch (Exception e) {
            System.out.println("Stronica nie istnieje");
        }
        return false;
    }

    static void putProcessToPageFile(int pID, Vector<Vector<Character>> program) {
        PageFile.put(pID, program);
    }

    //Uzywana przez ram żeby dostać konkretny numer ramki w której znaduje się stronica
    //pcb do odebrania tablicy storinic procesu
    static int demandPage(PCB proces, int PageID) {
        if (!PageTables.get(proces.ID).get(PageID).valid) {
            putPageInRam(proces, proces.ID, PageID);
        }
        return PageTables.get(proces.ID).get(PageID).nrramki;
    }

    static void takepageout(PCB proces, int frameID) {
        Vector<Page> pageTable = proces.getPageTable();
        int pageID = 0;
        for (int i = 0; i < pageTable.size(); i++) {
            if (pageTable.get(i).nrramki == frameID)
                pageID = i;
        }
        Vector<Character> page;
        page = Ram.readFrame(frameID);

        putPageInPageFile(pageID, proces.ID, page);
        updatePageTables(-1, -1, -1, false);
    }

    static void updatePageTables(int procID, int pageID, int frameID, boolean value) {
        PageTables.get(procID).get(pageID).nrramki = frameID;
        PageTables.get(procID).get(pageID).valid = value;
    }

    static void putPageInPageFile(int pageID, int procID, Vector<Character> page) {
        Vector<Vector<Character>> tmp = PageFile.get(procID);
        tmp.set(pageID, page);
        PageFile.put(procID, tmp);
    }

    static void putInfoToPageTable(int pID, Vector<Page> pageTable) {
        PageTables.put(pID, pageTable);
    }

    static boolean processExists(int procID) {
        return PageFile.containsKey(procID);
    }


    /**
     * Funkcje dla Ciechana
     */
    int matchPage(PCB proces, int pageID) {
        Vector<Page> pageTable = proces.getPageTable();
        if (pageTable.get(pageID).valid) {
            System.out.println("Stronica jest w ramie");
            return pageTable.get(pageID).nrramki;
        } else putPageInRam(proces, proces.ID, pageID);
        return 0;
    }

    int find(PCB proces, int adress) {
        int pageid = ((adress - adress % 32) / 32);
        int frameid = matchPage(proces, pageid);
        return frameid;
    }

    char readChar(PCB proces, int adress) {
        int frameid = find(proces, adress);
        char czytany = Memory.readFromFrame(adress, frameid);
        return czytany;
    }


    /**
     * Metody do wyświetlania
     */

    public static void printPageTable(int processID) {
        if (processExists(processID)) {
            for (int i = 0; i < PageTables.get(processID).size(); i++) {
                System.out.println(i + "   \t" + PageTables.get(processID).get(i).nrramki + "   \t" + PageTables.get(processID).get(i).valid);
            }
        } else System.out.println("Error: process with given ID doesn't exist.");
    }

    public static void printQueue() {
        Queue<Integer> tmp = new LinkedList<>(victimQueue);

        for (int i = 0; i < tmp.size(); i++) {
            System.out.println(tmp.poll() + " ");
        }
        System.out.println(" ");
    }

    public static void printPageFile(int processID) {
        if (processExists(processID)) {
            Vector<Vector<Character>> pages = PageFile.get(processID);
            int size=pages.size();
            if(size>1) size-=1;
            for (int i = 0; i < size; i++) {
                System.out.println("Page no." + i);
                for (int j = 0; j < pages.get(i).size(); j++) {
                    System.out.println(pages.get(i).get(j)+" ");
                }
            }
            System.out.println("");
        } else System.out.println("Error: process with given ID doesn't exist.");
    }

    public static void printPageFile() {
        System.out.println(PageFile.toString());
            System.out.println("");
    }
}
